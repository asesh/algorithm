//
//  main.cpp
//  consoleApp_1
//
//  Created by Asesh Shrestha on 1/4/20.
//  Copyright Â© 2020 Asesh Shrestha. All rights reserved.
//

#include "header.h"

#include "binary_tree.hpp"

#include "linked_list.h"
#include "path_finding.h"
#include "number.hpp"
#include "string.hpp"
#include "graph.hpp"
#include "trie.hpp"

int main(int argc, const char* argv[]) {
  invoke_populating_next_right_pointers_in_each_node_ii();
  
//  invoke_evaluate_reverse_polish_notation();
  
//  invoke_copy_list_with_random_pointer();
  
//  invoke_number_of_1_bits();
  
//  invoke_bitwise_and_of_numbers_range();
  
//  invoke_lru_cache();
  
//  invoke_single_number_ii();
  
//  invoke_find_the_prefix_common_array_of_two_arrays();
  
//  test_doubly_linked_list();
  
//  test_linked_list();
  
//  invoke_minimum_length_of_string_after_operations();
  
//  invoke_construct_k_palindrome_strings();
  
//  invoke_word_subsets();
  
//  invoke_partition_list();
  
//  invoke_subarray_sum_equals_k();
  
//  invoke_find_median_from_data_stream();
  
//  invoke_unique_length_three_palindromic_subsequences();
  
//  invoke_find_k_pairs_with_smallest_sums();
  
//  invoke_lowest_common_ancestor_binary_tree();
  
//  invoke_construct_binary_tree_from_inorder_and_postorder_traversal();
  
//  invoke_search_2d_matrix_ii();
  
//  invoke_quick_sort();
  
//  invoke_merge_sort();
  
//  invoke_find_first_and_last_position_of_element_in_sorted_array();
  
//  invoke_construct_binary_tree_from_pre_and_inorder_traversal();
  
//  invoke_flatten_binary_tree_to_linked_list();
  
//  invoke_rotate_list();
  
//  invoke_sum_root_to_leaf_number();
  
//  invoke_remove_duplicates_from_sorted_list_ii();
  
//  invoke_remove_nth_node_from_end_of_list();
  
//  invoke_kth_smallest_element_in_a_bst();
  
//  invoke_validate_binary_search_tree();
  
//  invoke_search_in_rotated_sorted_array();
  
//  invoke_sort_linked_list();
  
//  invoke_word_search();
  
//  invoke_combinations();
  
//  invoke_simplify_path();
  
//  invoke_maximum_sum_circular_subarray();
  
//  invoke_maximium_subarray();
  
//  invoke_letter_combination_of_a_phone_number();
  
//  invoke_merge_intervals();
  
//  invoke_min_stack();
  
//  invoke_longest_valid_parentheses();
  
//  invoke_word_search_ii();
  
//  invoke_search_a_2d_matrix();
  
//  invoke_combination_sum();
  
//  invoke_generate_parentheses();
  
//  invoke_find_peak_element();
  
//  invoke_longest_consecutive_sequence();
  
//  invoke_longest_common_prefx();
  
//  invoke_trie_methods();
  
//  invoke_gas_station();
  
//  invoke_h_index();
  
//  invoke_add_binary();
  
//  invoke_median_of_two_sorted_arrays();
  
//  invoke_valid_sudoku();
  
//  invoke_group_anagrams();
  
//  invoke_spiral_matrix();
  
//  invoke_minimum_path_sum();
  
//  invoke_permutations();
  
//  invoke_rotate_image();
  
//  invoke_level_order_traversal();
  
//  invoke_right_side_view();
  
//  invoke_longest_palindromic_substring();
  
//  invoke_minimum_size_subarray_sum();
  
//  invoke_longest_substring_without_repeating_characters();
  
//  invoke_string_to_integer();
  
//  invoke_minimum_remove_to_make_valid_parenthesses();
  
//  invoke_container_with_most_water();
  
//  invoke_zig_zag_conversion();
  
//  invoke_two_sum();
  
//  invoke_two_sum_ii();
  
//    invoke_find_three_number_sum();
  
//  invoke_separate_black_and_white_balls();
  
//  invoke_trapping_rain_water();
  
//  invoke_set_matrix_zeroes();
  
//  invoke_product_of_array_except_itself();
  
//  invoke_reverse_words_in_a_string();
  
//  invoke_four_number_sum();
  
//  invoke_jump_game_ii();
  
//  invoke_kth_largest_element_in_an_array();
  
//  invoke_is_subsequence();
  
//  invoke_integer_to_roman();
  
//  invoke_jump_game();
  
//  invoke_best_time_to_buy_and_sell_stock_ii();
  
//  invoke_reverse_integer();
  
//  invoke_rotate_array();
  
//  invoke_remove_element();
  
//  invoke_merge_sorted_arrays();
  
//  invoke_insert_and_shift_numbers();
  
//  std::array<int, 6> input_array = {1, 2, 3, 4};
//  merge_sort(input_array, 0, input_array.size() - 1);
  
  // Minheap
//  MinHeap min_heap({48, 12, 24, 7, 8, -5, 24, 391, 24, 56, 2, 6, 8, 41});
//  min_heap.insert(76);
//  min_heap.remove();
//  min_heap.remove();
  
//  invoke_valid_palindrome_2();
  
//  std::vector<int> denoms = {1, 2, 5};
//  test_recursion(denoms, 5);
  
//  std::vector<std::vector<int>> visted(5, std::vector<int>(10, false));
  
//  invoke_river_size();
  
//  invoke_levenshtein_distance();
  
//  invoke_river_sizes();
  
//  invoke_number_of_ways_to_traverse_graph();
  
//  invoke_calculate_minimum_number_of_steps();
  
//  invoke_calculate_number_of_steps();
  
//  invoke_calculate_minimum_coins();
  
//  std::cout<<(-1%10)<<std::endl;
  
//  create_undirected_graph();
//  create_directed_graph();
  
//  auto missing_numbers = missingNumbers({1, 2, 4, 5, 7});
//  std::cout<<std::endl;
//  for(auto& number: missing_numbers) {
//    std::cout<<number<<", ";
//  }
  
	
//	std::vector<std::string> output = {"abc", "bcd", "cdef"};
//	std::unordered_set<char> unique_characters(output[0].begin(), output[0].end());
//	for(const auto& character: unique_characters) {
//		std::cout<<character<<" ";
//	}
	
	// (b + (a%b)) % b
//	int number = -2;
//	int max = 6;
//	int value = (max + (number % max)) % max;
//	std::cout<<value<<std::endl;
	
//	std::unordered_map<int, std::string> hash_map{
//		{0, "a"},
//		{1, "b"},
//		{2, "c"},
//	};
//	for(const auto& key: hash_map) {
//		std::cout<<key.first<<std::endl;
//	}
	
//	LinkedList* head = new LinkedList(0);
//	head->next = new LinkedList(1);
//	head->next->next = new LinkedList(2);
//	head->next->next->next = new LinkedList(3);
//	head->next->next->next->next = new LinkedList(4);
//	head->next->next->next->next->next = new LinkedList(5);
//	shiftLinkedList(head, 2);
//	delete head->next->next->next->next->next;
//	delete head->next->next->next->next;
//	delete head->next->next->next;
//	delete head->next->next;
//	delete head->next;
	
//	rat_in_a_maze();
	
//	std::string input = "cinema";
//	std::cout<<std::boolalpha<<is_anagram(input, "iceman");
	
//	auto position = input.find("H");
//	input.erase(position, 1);
//	std::cout<<"After: "<< input << std::endl;
//	auto iter = input.begin();
//	while(iter != input.end()) {
//		if(*iter == 'l') {
//			iter = input.erase(iter);
//		} else {
//			++iter;
//		}
//	}
//	std::cout<<input<<std::endl;
	
//	invoke_binary_search_tree();
//	std::string input_string = "Hello world!!";
//	if(input_string.find('H', 1) == std::string::npos) {
//		std::cout<<"Not found"<<std::endl;
//	} else {
//		std::cout<<"Found"<<std::endl;
//	}
	
//	std::vector<std::vector<int>> array_of_array = {{1, 2}, {4, 7}, {9, 11}, {4, 5}, {6, 8}};
//	std::sort(array_of_array.begin(), array_of_array.end());
//	for(auto& list: array_of_array) {
//		std::cout<<list[0]<<std::endl;
//	}
	
//	std::vector<int> output = {INT_MIN, INT_MIN, INT_MIN};
//	for(const auto& number: output) {
//		std::cout<<number<<", ";
//	}
	
//	std::vector<int> array = {-4, 5, 10, 8, -10, -6, -4, -2, -5, 3, 5, -4, -5, -1, 1, 6, -7, -6, -7, 8};
//	insertion_sort(array);
//	for(const auto& current_number: array) {
//		std::cout<<current_number<<", ";
//	}
	
//	bubble_sort({5, 1, 4, 2, 8});
	
//	test_coroutine();
	
//	std::vector<std::any> container;
//	container.push_back(12);
//	container.push_back('[');
//	container.push_back("hello");
//	for(const auto& data: container) {
//		if(data.type() == typeid(int)) {
//			std::cout<<std::any_cast<int>(data)<<std::endl;
//		} else if(data.type() == typeid(const char*)) {
//			std::cout<<std::any_cast<const char*>(data)<<std::endl;
//		} else if(data.type() == typeid(std::string)) {
//			std::cout<<std::any_cast<std::string>(data)<<std::endl;
//		} else if(data.type() == typeid(char)) {
//			std::cout<<std::any_cast<char>(data)<<std::endl;
//		}
//	}
	
	
//	std::cout<<std::boolalpha<<isMonotonic({1,3,2});
	
//	std::cout<<0x7fffffff<<std::endl;
	
//	std::string output;
//	output.reserve(5);
//
//	output.push_back(0x41);
//	output.push_back(0x42);
//	output.push_back(0x43);
//	output.push_back(0x44);
//	std::cout<<output<<std::endl;
	
	/*
	 max heap:
	 input:
			70
		10	50
	 80
	 
	 output:
	    80
		70  50
	 10
	 */
	
//	invoke_longest_palindromic_substring();
	
//	std::map<std::string, int> hash_map;
//	hash_map.insert(std::pair<std::string, int>("hello", 1));
//	hash_map.insert(std::pair<std::string, int>("world", 2));
//	hash_map.insert(std::pair<std::string, int>("hello", 4));
//	for(const auto& data: hash_map) {
//		std::cout<<"Key: "<<data.first<<",value: "<<data.second<<std::endl;
//	}
	
//	invoke_find_pivot_index();

//	invoke_sliding_window();
	
	// Rotate linked list
//	rotate_linked_list();
	
//	add_two_numbers();
	
	//int input_array[] = {38, 27, 43, 3, 9, 82, 10};
	/*
	 38, 27, 43, 3, 9, 82, 10
	 */
//	fake_merge_sort(input_array, 0, sizeof(input_array)/sizeof(input_array[0]));
	
	
	// Convert vector into heap
//	std::vector<int> numbers {1, 9, 2, 3, 4, 5, 6, 7, 8, 10, 9};
//	std::make_heap(numbers.begin(), numbers.end());
//	for(const auto& number: numbers) {
//		std::cout << number << std::endl;
//	}
	
//	std::cout<< std::boolalpha << min_adjancent_swaps_for_palindromic_string("nitin");
	
	// Reorganize string
//	std::cout<<reorganize_string("aaabc");

//	invoke_reverse_linked_list();
	
//	invoke_binary_search();
	
//	int array[] = {0, 1};
//	std::swap(array[0], array[1]);
//	std::cout<<array[0]<<", "<<array[1]<<std::endl;
	
	//recursive_call(3);
	
//	invoke_longest_substring_without_repeating_characters();
	
	// Min integer limit
//	short shortest_number = -0x8000;
//	std::wcout<< std::showbase << std::hex << shortest_number << std::endl;
//	std::wcout<< std::showbase << std::hex << std::numeric_limits<short>::min() << std::endl;
	
//	std::wcout<< std::hex << std::showbase << "INT_MAX: " << INT_MAX << ", INT_MIN: " << INT_MIN << ", UINT_MAX: " << UINT_MAX << std::endl;
	
	// Check cv signal
//	check_cv.notify_one();
//	std::this_thread::sleep_for(std::chrono::milliseconds(500));
//	check_condition_variable();
	
	
//	std::wcout << (is_number_palindrome(121) == true ? L"It's palindrome" : L"It's not palindrome") << std::endl;
	
	/*
	 2 -> 4 -> 3
	 5 -> 6 -> 4
	 */
//	ReverseLinkedList rll(1);
//	rll.add(2);
//	rll.add(3);
//	rll.add(4);
//	ReverseLinkedList rl2(5);
//	rl2.add(6);
//	rl2.add(4);
//	rll.traverse();
	
	
	// Merge sort
//	int input_merge_sort_array[] = {1, 2, 3, 4, 5, 6, 7, 8};
//	int number_of_elements = sizeof(input_merge_sort_array) / sizeof(input_merge_sort_array[0]);
//
//	merge_sort(input_merge_sort_array, 0, number_of_elements - 1);
	
	// Ref 1
//	print_reverse(input_merge_sort_array, 0, number_of_elements);
	
	//split_merge(input_merge_sort_array, 0, number_of_elements);
	
	// 1100
//	std::cout<< (3 << 2) << std::endl;
	
//	int32_t input_array[] = {1, 2, 3, 4};
//	split_and_print(input_array, 0, (sizeof(input_array)/sizeof(input_array[0])) -1);
//	sliding_window_print(input_array, 2, 0, 3);
	
	// Higher to lower
//	int input_array[] = {2, 3, 5, 1, 4, 6};
//	int number_of_elements = (sizeof(input_array)/sizeof(input_array[0])-1);
//	high_to_low(input_array, number_of_elements - 1, number_of_elements);
	
	// Native messaging host
//	std::filesystem::current_path("/Users/aseshshrestha/Library/Developer/Xcode/DerivedData/algorithm-gxqdxcwbhwlaotdrxhscwxsxzwai/Build/Products/Debug");
//	std::cout<<std::filesystem::current_path()<<std::endl;
	

	
//	std::this_thread::sleep_for(std::chrono::seconds(15));
//
//	message_to_extension = R"({"type": "start", "message": "Should be discarded"})";
//	send_message_to_chromium(2*1024*1024, message_to_extension);
//
//	std::this_thread::sleep_for(std::chrono::seconds(15));
//
//	message_to_extension = R"({"type": "start", "message": "Should be visible"})";
//	send_message_to_chromium(message_to_extension.length(), message_to_extension);



//	// Path finding
//	draw_grid(50, 50);
	
	
//	std::cout<< "The longest is: " << longest_substring_without_repeating_characters("pwwkew") << std::endl;
	
//	binary_tree();
	
	
//	std::cout<<recursive_sum(5)<<std::endl;
	
//	recursive_print_braces(5);
	
	//
//	const int input_array[] = {1, 2, 3, 4, 6, 2, 11, 7, 15};
//	auto indices_pair = two_sum_equals_specific_target(input_array, sizeof(input_array)/sizeof(input_array[0]), 9);
//	std::cout<<"First index: " << indices_pair.first << ", 2nd index: " << indices_pair.second << std::endl;
	
	
	// Permutation of string
//	std::string input_string = "ABC";
//	permutation_of_string(input_string, 0, input_string.length() - 1);
	

	// Sum of consecutive numbers using sliding window technique
//	int array[] = {5, 2, 7, 1, 3, 8};
//	auto max_sum = get_max_sum_of_consecutive_numbers(array, sizeof(array) / sizeof(array[0]), 3);
//	std::wcout << std::endl << "The max sum is: " << max_sum << std::endl;
	
	
//	// Swap array items
//	std::array<int, 7> input_array = {1, 2, 3, 4, 5, 6, 7};
//	std::array<int, 7> output_array;
//	reverse_array(input_array, output_array);
//	for(const auto& array_item: output_array) {
//		std::cout<< array_item << std::endl;
//	}
	
	
	// Binary search
//	int number_array[] = {1, 3, 4, 7, 9, 11, 13};
//	int higher_index = (sizeof(number_array) / sizeof(number_array[0])) - 1;
//	auto number_index = binary_search(number_array, 11, 0, higher_index);
//	std::cout << "The index of the number is: " << number_index << std::endl;
	// End of "Invocation of binary_search"
	
	
	
	// Doubly linked list
//	auto doubly_linked_list = std::make_unique<CDoubleLinkedList<int>>(12);
//	doubly_linked_list->add_previous_node(11);
//	doubly_linked_list->add_previous_node(10);
//	doubly_linked_list->add_previous_node(9);
//	doubly_linked_list->add_previous_node(8);
//	doubly_linked_list->add_previous_node(7);
//	doubly_linked_list->add_next_node(13);
//	doubly_linked_list->add_next_node(14);
//	doubly_linked_list->add_next_node(15);
//	doubly_linked_list->add_next_node(16);
//	doubly_linked_list->add_next_node(17);
//	doubly_linked_list->print_all();
	
	
	
	// Single linked list
//	auto single_linked_list = std::make_unique<CSingleLinkedList<int>>();
//	single_linked_list->add_node(2);
//	single_linked_list->add_node(3);
//	single_linked_list->add_node(4);
//
//	single_linked_list->print_all();
//
//	single_linked_list->destroy();
	
	// End of "Single linked list"
	
	
//	std::unique_ptr<CDoubleLinkedList<int>> double_linked_list;
  
//  std::filesystem::path current_path("");
//  auto path_exists = std::filesystem::exists(current_path);
//  std::wcout << path_exists << std::endl;
  
//  std::wcout<< std::filesystem::current_path() << std::endl;
  
//  std::array<uint8_t, 5> binary_tree_items = {1, 2, 3, 4, 5};
//  CBinaryTree<uint8_t, binary_tree_items.size()> binary_tree = {binary_tree_items};
  
//  std::array<int, 7> integer_array = {5, 4, 8, 9, 2, 0, 3};
//  sort_array(integer_array, integer_array.size());
//
//  std::cout << "Partially sorted array: ";
//  for(auto array_item : integer_array) {
//    std::cout<< array_item << " ";
//  }
//
//  return 0;
//}
//
//void sort_array(std::array<int, 7>& integer_array, int number_of_items) {
//  int counter = 0;
//  for(const auto& array_item : integer_array) {
////    std::cout<< array_item << std::endl;
//    if(array_item > integer_array[counter + 1]) {
//      auto value = integer_array[counter + 1];
//      integer_array[counter + 1] = array_item;
//      integer_array[counter] = value;
//    }
//    counter++;
//    if(counter + 1 == integer_array.size()) {
//      break;
//    }
//  }
	
	std::cout<<std::endl;
}
